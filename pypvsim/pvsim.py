'''
Module contains objects that simulate physical parts of a solar PV
system, such as inverters, batteries, clear sky insolation, and solar
panels.
'''
import scipy as sp
import scipy.interpolate as spi
from numpy import sin, cos, tan, arcsin, arccos, pi, exp
import numpy as np


class Inverter:
    '''
    Simulates an inverter allowing for calculation of input energy
    demand based on output energy needed by load.  An input/output curve
    is interpolated to estimate power demanded by the inverter to
    satisfy the load.

    output_curve is a dictionary with two arrays.  these arrays are the
    corresponding input and output power of the inverter.
    '''
    def __init__(self, output_curve):
        self.output_curve = output_curve

    def input_power(self, load):
        input_power = spi.interp1d(self.output_curve['output_power'],
                                   self.output_curve['input_power'])
        return input_power(load)


class Battery:
    '''
    Simulates battery efficiency based on power draw.  The class is
    initialized using a dictionary, efficiency curve that has the output
    power and energy efficiency of the battery at that load.  This
    allows for the simulation of the decreased efficiency at high
    current demand.

    The class does not currently model the state of charge of the
    battery.
    '''
    # TODO: include storage or state of charge?
    def __init__(self, efficiency_curve):
        self.efficiency_curve = efficiency_curve

    def efficiency(self, load):
        efficiency = spi.interp1d(self.efficiency_curve['output_power'],
                                  self.efficiency_curve['efficiency'])
        return efficiency(load)


class Solar:
    '''
    Implements a clear-sky insolation model given latitude, longitude,
    panel tilt, and solar constant.
    '''
    # TODO: decide whether lat and lon go here or in the panel class
    # TODO: longitude to calculate hour angle and adjust for solar noon?
    lat = sp.radians(0)
    lon = sp.radians(0)
    el_tilt = sp.radians(0)
    az_tilt = sp.radians(0)
    solar_constant = 1.377

    def __init__(self, lat=40):
        self.lat = sp.radians(lat)

    def day_of_year(self, date):
        # '%j' gives day of year
        return int(date.strftime('%j'))

    def declination(self, date):
        day_of_year = self.day_of_year(date)
        return sp.radians(23.45 * sp.sin(2 * sp.pi * (day_of_year - 81) / 365.0))

    def hour_angle(self, date):
        # TODO: is there a better way to convert time to decimal hours?
        # '%H' gives hour of day
        # '%M' gives minutes
        decimal_hour = float(date.strftime('%H')) + float(date.strftime('%M')) / 60.
        return sp.radians(15 * (decimal_hour - 12))


    def elevation(self, date):
        # angle between horizontal plane and the sun
        dec = self.declination(date)
        ha = self.hour_angle(date)
        arg = sp.cos(self.lat) * sp.cos(dec) * sp.cos(ha) + sp.sin(self.lat) * sp.sin(dec)
        el = np.arcsin(arg)
        # do not return negative elevations, instead return NAN
        if arg > 0:
            return el
        else:
            return np.nan

    def azimuth(self, date):
        dec = self.declination(date)
        ha = self.hour_angle(date)
        el = self.elevation(date)
        # azimuth from pg 450 da Rosa FREP
        az = np.arctan2(sin(ha), sin(self.lat) * cos(ha) - cos(self.lat) * tan(dec))
        # if elevation does not exist, return a NAN
        if el == np.nan:
            return np.nan
        else:
            return az

    def extraterrestrial_insolation(self, date):
        day_of_year = self.day_of_year(date)
        return self.solar_constant * (1 + 0.034 * cos(2 * pi * day_of_year / 365))

    def apparent_extraterrestrial_flux(self, date):
        day_of_year = self.day_of_year(date)
        return 1160 + 75 * sin(2 * pi * (day_of_year - 275) / 365)

    def optical_depth(self, date):
        day_of_year = self.day_of_year(date)
        return 0.174 + 0.035 * sin(2 * pi * (day_of_year - 100) / 365)

    def air_mass_ratio(self, date):
        return 1 / sin(self.elevation(date))

    def direct_beam_radiation(self, date):
        return self.apparent_extraterrestrial_flux(date) * exp(- self.optical_depth(date)
                                                               * self.air_mass_ratio(date))


class Panel:
    '''
    Takes a Solar object as input and returns the power generated by the
    panel given the area and efficiency and tilt of the panel.
    el_tilt is the angle between the horizontal and the back of the
    panel
    '''
    # TODO: how to simulate a single and double axis tracking system?
    def __init__(self, solar, area=1, efficiency=0.20, el_tilt=0, az_tilt=0):
        self.area = area
        self.efficiency = efficiency
        #self.el_tilt = sp.radians(el_tilt)
        #self.az_tilt = sp.radians(az_tilt)
        self.el_tilt = el_tilt
        self.az_tilt = az_tilt
        self.solar = solar

    def incidence_angle(self, date):
        dec = self.solar.declination(date)
        el = self.solar.elevation(date)
        az = self.solar.azimuth(date)
        return arccos(cos(el) * cos(az - self.az_tilt) * sin(self.el_tilt)
                      + sin(el) * cos(self.el_tilt))

    def radiation_normal_panel(self, date):
        ins = self.solar.direct_beam_radiation(date) * cos(self.incidence_angle(date))
        if ins > 0:
            return ins
        else:
            return 0

    def power(self, date):
        return self.area * self.efficiency * self.radiation_normal_panel(date)
